# -*- coding: utf-8 -*-
"""Tumor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1px5gdweoUKJ93f9r6vzP7igUrJrTylU1
"""

import os
import pandas as pd
import numpy as np
import cv2
import matplotlib.pyplot as plt

#all the imports go here for deep learming
from tensorflow.keras.optimizers import SGD
from keras.models import Sequential,Model, load_model
from keras.layers import Dropout, Flatten, Dense,Input, GlobalAveragePooling2D
from keras.applications.resnet import ResNet50
from keras.callbacks import ModelCheckpoint, EarlyStopping, ReduceLROnPlateau
from keras.preprocessing.image import ImageDataGenerator

# from google.colab import drive
# drive.mount('/content/drive')

#Flip the images horizontally
image_names = os.listdir('/content/drive/MyDrive/Brain Tumor/Brain_tumor_new/train/G1')

count = 1
for image_name in image_names:
	#This skip in loop is added to ensure that directories are not read as images
  image_path = '/content/drive/MyDrive/Brain Tumor/Brain_tumor_new/train/G1/'+image_name
  new_imagename = image_name.replace('.jpg', 'flipped.jpg')
  new_image_path = "/content/drive/MyDrive/Brain Tumor/Brain_tumor_new/train/G1/"+image_name
  new_image_path1 = "//content/drive/MyDrive/Brain Tumor/Brain_tumor_new/train/G1/"+new_imagename
  image = cv2.imread(image_path)
  image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
  flipped = cv2.flip(image, 1)
  cv2.imwrite(new_image_path, image)
  cv2.imwrite(new_image_path1, flipped)
  count=count+1
  if(count%50==0):
    print(count)

#Flip the images horizontally
image_names = os.listdir('/content/drive/MyDrive/Brain Tumor/Brain_tumor_new/train/G3')

count = 1
for image_name in image_names:
	#This skip in loop is added to ensure that directories are not read as images
  image_path = '/content/drive/MyDrive/Brain Tumor/Brain_tumor_new/train/G3/'+image_name
  new_imagename = image_name.replace('.jpg', 'flipped.jpg')
  new_image_path = "/content/drive/MyDrive/Brain Tumor/Brain_tumor_new/train/G3/"+image_name
  new_image_path1 = "/content/drive/MyDrive/Brain Tumor/Brain_tumor_new/train/G3/"+new_imagename
  image = cv2.imread(image_path)
  image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
  flipped = cv2.flip(image, 1)
  cv2.imwrite(new_image_path, image)
  cv2.imwrite(new_image_path1, flipped)
  count=count+1
  if(count%50==0):
    print(count)

image_names = os.listdir('/content/drive/MyDrive/Brain Tumor/Brain_tumor_new/train/G1')
print(len(image_names))

image_names = os.listdir('/content/drive/MyDrive/Brain Tumor/Brain_tumor_new/train/G2')
print(len(image_names))
count=0
for image_name in image_names:
  image_path = '/content/drive/MyDrive/Brain Tumor/Brain_tumor_new/train/G2/'+image_name
  new_imagename1 = image_name.replace('.jpg', 'rotl.jpg')
  new_imagename2 = image_name.replace('.jpg', 'rotr.jpg')
  new_image_path1 = "/content/drive/MyDrive/Brain Tumor/Brain_tumor_new/train/G2/"+new_imagename1
  new_image_path2 = "/content/drive/MyDrive/Brain Tumor/Brain_tumor_new/train/G2/"+new_imagename2
  image = cv2.imread(image_path)
  image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
  random_pos=np.random.randint(3,20)
  random_neg=np.random.randint(-20,-3)
  M_pos = cv2.getRotationMatrix2D((256,256), random_pos, 1)
  M_neg = cv2.getRotationMatrix2D((256,256), random_neg, 1)
  rotated_pos = cv2.warpAffine(image, M_pos, (512, 512))
  rotated_neg = cv2.warpAffine(image, M_neg, (512, 512))
  cv2.imwrite(new_image_path1, rotated_neg)
  cv2.imwrite(new_image_path2, rotated_pos)
  count=count+1
  if(count%100==0):
    print(count)

image_names = os.listdir('/content/drive/MyDrive/Brain Tumor/Brain_tumor_new/train/G4')
print(len(image_names))
count=0
for image_name in image_names:
  image_path = '/content/drive/MyDrive/Brain Tumor/Brain_tumor_new/train/G4/'+image_name
  new_imagename1 = image_name.replace('.jpg', 'rotl.jpg')
  new_imagename2 = image_name.replace('.jpg', 'rotr.jpg')
  new_image_path1 = "/content/drive/MyDrive/Brain Tumor/Brain_tumor_new/train/G4/"+new_imagename1
  new_image_path2 = "/content/drive/MyDrive/Brain Tumor/Brain_tumor_new/train/G4/"+new_imagename2
  image = cv2.imread(image_path)
  image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
  random_pos=np.random.randint(3,20)
  random_neg=np.random.randint(-20,-3)
  M_pos = cv2.getRotationMatrix2D((256,256), random_pos, 1)
  M_neg = cv2.getRotationMatrix2D((256,256), random_neg, 1)
  rotated_pos = cv2.warpAffine(image, M_pos, (512, 512))
  rotated_neg = cv2.warpAffine(image, M_neg, (512, 512))
  cv2.imwrite(new_image_path1, rotated_neg)
  cv2.imwrite(new_image_path2, rotated_pos)
  count=count+1
  if(count%100==0):
    print(count)

#Flip the images horizontally
train_datagen = ImageDataGenerator(
    rescale=1./255,
    width_shift_range=0.1,
    height_shift_range=0.1,
    zoom_range=0.1)
test_datagen = ImageDataGenerator(rescale=1./255)

train_path = "/content/drive/MyDrive/Brain Tumor/Tumor"

#Use categorical classmode for generator in multi class
train_generator = train_datagen.flow_from_directory(train_path+'/train',
    target_size=(512,512),
    batch_size=10,
    class_mode='categorical',
    color_mode="grayscale",
    shuffle=True)

validation_generator = test_datagen.flow_from_directory(train_path+'/test',
    target_size=(512,512),
    batch_size=10,
    class_mode='categorical',
    color_mode="grayscale",
    shuffle=True)
pip install keras-ocr

import matplotlib.pyplot as plt
import keras_ocr
import cv2
import math
import numpy as np
def midpoint(x1, y1, x2, y2):
    x_mid = int((x1 + x2)/2)
    y_mid = int((y1 + y2)/2)
    return (x_mid, y_mid)
pipeline = keras_ocr.pipeline.Pipeline()
def inpaint_text(img_path, pipeline):
    # read image
    img = keras_ocr.tools.read(img_path)
    # generate (word, box) tuples
    prediction_groups = pipeline.recognize([img])
    mask = np.zeros(img.shape[:2], dtype="uint8")
    for box in prediction_groups[0]:
        x0, y0 = box[1][0]
        x1, y1 = box[1][1]
        x2, y2 = box[1][2]
        x3, y3 = box[1][3]

        x_mid0, y_mid0 = midpoint(x1, y1, x2, y2)
        x_mid1, y_mi1 = midpoint(x0, y0, x3, y3)

        thickness = int(math.sqrt( (x2 - x1)**2 + (y2 - y1)**2 ))

        cv2.line(mask, (x_mid0, y_mid0), (x_mid1, y_mi1), 255,
        thickness)
        img = cv2.inpaint(img, mask, 7, cv2.INPAINT_NS)

    return(img)

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

image_names = os.listdir('/content/drive/MyDrive/Brain Tumor/Tumor/train/G1')
for image_name in image_names:
  path='/content/drive/MyDrive/Brain Tumor/Tumor/train/G1/'+image_name
  # img=cv2.imread(path)
  # plt.imshow(img)
  img_new=inpaint_text(path,pipeline)
  new_image_path1="/content/drive/MyDrive/Brain Tumor/Tumor_free/train/G1/"+image_name
  cv2.imwrite(new_image_path1, img_new)
# plt.imshow(img_new)

image_names = os.listdir('/content/drive/MyDrive/Brain Tumor/Tumor/train/G1/')
new1=os.listdir("/content/drive/MyDrive/Brain Tumor/Tumor_free/train/G1/")
print(len(image_names))
print(len(new1))

image_names = os.listdir('/content/drive/MyDrive/Brain Tumor/Tumor/train/G2')
count=0
for image_name in image_names:
  path='/content/drive/MyDrive/Brain Tumor/Tumor/train/G2/'+image_name
  # img=cv2.imread(path)
  # plt.imshow(img)
  img_new=inpaint_text(path,pipeline)
  new_image_path1="/content/drive/MyDrive/Brain Tumor/Tumor_free/train/G2/"+image_name
  cv2.imwrite(new_image_path1, img_new)
  count+=1
  print(count)

image_names = os.listdir('/content/drive/MyDrive/Brain Tumor/Tumor/train/G3')
count=0
for image_name in image_names:
  path='/content/drive/MyDrive/Brain Tumor/Tumor/train/G3/'+image_name
  # img=cv2.imread(path)
  # plt.imshow(img)
  img_new=inpaint_text(path,pipeline)
  new_image_path1="/content/drive/MyDrive/Brain Tumor/Tumor_free/train/G3/"+image_name
  cv2.imwrite(new_image_path1, img_new)
  count+=1
  print(count)

image_names = os.listdir('/content/drive/MyDrive/Brain Tumor/Tumor/train/G4')
count=0
for image_name in image_names:
  path='/content/drive/MyDrive/Brain Tumor/Tumor/train/G4/'+image_name
  # img=cv2.imread(path)
  # plt.imshow(img)
  img_new=inpaint_text(path,pipeline)
  new_image_path1="/content/drive/MyDrive/Brain Tumor/Tumor_free/train/G4/"+image_name
  cv2.imwrite(new_image_path1, img_new)
  count+=1
  print(count)

image_names = os.listdir('/content/drive/MyDrive/Brain Tumor/Tumor/test/G1')
count=0
for image_name in image_names:
  path='/content/drive/MyDrive/Brain Tumor/Tumor/test/G1/'+image_name
  # img=cv2.imread(path)
  # plt.imshow(img)
  img_new=inpaint_text(path,pipeline)
  new_image_path1="/content/drive/MyDrive/Brain Tumor/Tumor_free/test/G1/"+image_name
  cv2.imwrite(new_image_path1, img_new)
  count+=1
  print(count)

image_names = os.listdir('/content/drive/MyDrive/Brain Tumor/Tumor/test/G2')
count=0
for image_name in image_names:
  path='/content/drive/MyDrive/Brain Tumor/Tumor/test/G2/'+image_name
  # img=cv2.imread(path)
  # plt.imshow(img)
  img_new=inpaint_text(path,pipeline)
  new_image_path1="/content/drive/MyDrive/Brain Tumor/Tumor_free/test/G2/"+image_name
  cv2.imwrite(new_image_path1, img_new)
  count+=1
  print(count)

image_names = os.listdir('/content/drive/MyDrive/Brain Tumor/Tumor/test/G3')
count=0
for image_name in image_names:
  path='/content/drive/MyDrive/Brain Tumor/Tumor/test/G3/'+image_name
  # img=cv2.imread(path)
  # plt.imshow(img)
  img_new=inpaint_text(path,pipeline)
  new_image_path1="/content/drive/MyDrive/Brain Tumor/Tumor_free/test/G3/"+image_name
  cv2.imwrite(new_image_path1, img_new)
  count+=1
  print(count)

image_names = os.listdir('/content/drive/MyDrive/Brain Tumor/Tumor/test/G4')
count=0
for image_name in image_names:
  path='/content/drive/MyDrive/Brain Tumor/Tumor/test/G4/'+image_name
  # img=cv2.imread(path)
  # plt.imshow(img)
  img_new=inpaint_text(path,pipeline)
  new_image_path1="/content/drive/MyDrive/Brain Tumor/Tumor_free/test/G4/"+image_name
  cv2.imwrite(new_image_path1, img_new)
  count+=1
  print(count)

#Training the model
# The model produces separate layers and also doesn't include the Resnet as a one Layer
input_tensor=Input(shape=(512,512,1))

#Load EfficientNetB0 ImageNet pre-trained weights
weight_model = ResNet50(weights='imagenet', include_top=False)
#Save the weights
weight_model.save_weights('weights_eff.h5')
#Load the EfficientnetB1 model without weights
base_model = ResNet50(weights=None, include_top=False, input_tensor=input_tensor)
#Load the ImageNet weights on the ResNet50V2 model except the first layer(because the first layer has one channel in our case)
base_model.load_weights('weights_eff.h5',skip_mismatch=True, by_name=True)
x = Dropout(0.2)(base_model.output)
x = GlobalAveragePooling2D()(x)
x = Dense(32, activation='relu', kernel_initializer='uniform') (x)
x = Dropout(0.2)(x)
x = Dense(4, activation='softmax')(x)
model = Model(inputs=input_tensor , outputs=x)

#setting teh training parametrs
for layer in model.layers:
  layer.trainable = True
#DECIDING THE CALLBACKS
#optimizer=Nadam(learning_rate=0.0001)
optimizer = SGD(lr=0.001, decay=1e-6, momentum=0.1, nesterov=True)
#optimizer = SGD(learning_rate=0.001, momentum=0.0, nesterov=False)
#early stopping to monitor the validation loss and avoid overfitting
early_stop = EarlyStopping(monitor='val_accuracy', mode='max', verbose=1, patience=3, restore_best_weights=True)

#reducing learning rate on plateau
rlrop = ReduceLROnPlateau(monitor='val_accuracy', mode='max', patience= 3, factor= 0.5, min_lr= 1e-7, verbose=1)#model compiling

ModelCheck = ModelCheckpoint('/content/drive/MyDrive/Brain_Tumor/trained_models/model_today_aug-{epoch:02d}-{val_accuracy:.4f}.hdf5',
                            monitor='val_loss',
                            mode='min',
                            save_best_only=True,
                            verbose=1)

ModelCheck = ModelCheckpoint('/content/drive/MyDrive/Brain Tumor/trained_models/model_today_oct-{epoch:02d}-{accuracy:.4f}----{val_accuracy:.4f}.hdf5')
model.compile(optimizer=optimizer, loss='categorical_crossentropy', metrics=['accuracy'])

# #Start the training
callbacks_list = [ early_stop, rlrop, ModelCheck]
model.fit_generator(train_generator, epochs=30,validation_data=validation_generator,callbacks=callbacks_list, steps_per_epoch=(2552//10))



# metrics
image_names_g1 = os.listdir('../input/tumor-free/Tumor_free/test/G1')
image_names_g2 = os.listdir('../input/tumor-free/Tumor_free/test/G2')
image_names_g3 = os.listdir('../input/tumor-free/Tumor_free/test/G3')
image_names_g4 = os.listdir('../input/tumor-free/Tumor_free/test/G4')

print("Total Image is Tumor G1 class : {}, Total Image is Tumor G2 class : {} ,Total Image is Tumor G3 class : {} and Tumor G4 class : {}".format(len(image_names_g1), len(image_names_g2),len(image_names_g3),len(image_names_g4)))
TP=0
FP=0
TN=0
FN=0
total_count=0

#Load the model
model = load_model("./model_today_oct-05-0.6467----0.4094.hdf5")

#Check the images in tumor folder
for image_name in image_names_g1:
  image_path = '../input/tumor-free/Tumor_free/test/G1/'+image_name
  img = cv2.imread(image_path,cv2.IMREAD_GRAYSCALE) #load image
  img = cv2.resize(img,(512,512))
  data = img/255.
  data = data.reshape((1,512,512,1))
  predictions = model.predict(data)
  if(np.argmax(predictions)==1):
    TP+=1
  else:
    FN+=1
  total_count+=1
  if(total_count%50==0):
    print(total_count)
for image_name in image_names_g2:
  image_path = '../input/tumor-free/Tumor_free/test/G2/'+image_name
  img = cv2.imread(image_path,cv2.IMREAD_GRAYSCALE) #load image
  img = cv2.resize(img,(512,512))
  data = img/255.
  data = data.reshape((1,512,512,1))
  predictions = model.predict(data)
  if(np.argmax(predictions)==1):
    TP+=1
  else:
    FN+=1
  total_count+=1
  if(total_count%50==0):
    print(total_count)

for image_name in image_names_g3:
  image_path = '../input/tumor-free/Tumor_free/test/G3/'+image_name
  img = cv2.imread(image_path,cv2.IMREAD_GRAYSCALE) #load image
  img = cv2.resize(img,(512,512))
  data = img/255.
  data = data.reshape((1,512,512,1))
  predictions = model.predict(data)
  if(np.argmax(predictions)==1):
    TP+=1
  else:
    FN+=1
  total_count+=1
  if(total_count%50==0):
    print(total_count)

for image_name in image_names_g4:
  image_path = '../input/tumor-free/Tumor_free/test/G4/'+image_name
  img = cv2.imread(image_path,cv2.IMREAD_GRAYSCALE) #load image
  img = cv2.resize(img,(512,512))
  data = img/255.
  data = data.reshape((1,512,512,1))
  predictions = model.predict(data)
  if(np.argmax(predictions)==1):
    TP+=1
  else:
    FN+=1
  total_count+=1
  if(total_count%50==0):
    print(total_count)

  Acc = (TP+TN)/640
  print(Acc)